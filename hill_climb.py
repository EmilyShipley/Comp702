import signal_estimator
import numpy as np


def hill_climb(input_row,cal_process_row,step_size,num_neighbours):
    """Completes a hill-climb on one pair of ports at a time, by generating a number of neighbouring sets of coordinates and replacing
       the current coordinates with a 'neighbour' if the neighbour produces a better signal.
       
       PARAMETERS: 
                    input_row is the set of 4 coordinates and their signal for the input-output pair the hill-climb should be applied to.
                    cal_process_row is the row of the calibration process used to estimate the signals for the neighbours.
                        (This should be the row corresponding to the same input-output pair as input_row) 
                    step_size is the amount by which each coordinate should be increased or decreased to generate the next neighbour.
                    num_neighbours is the number of neighbours the algorithm will generate for each of the 4 coordinates.
                        num_neighbours must be an even number, and the total number of neighbours considered will be 4*num_neighbours.
                    
                    (E.g. if num_neighbours = 6, and step_size=10, the 6 neighbours for each coordinate will be generated by adding 10, 
                          adding 20, adding 30, subtracting 10, subtracting 20, and subtracting 30 from that coordinate."""
    current_coords = np.copy(input_row)
    if np.shape(current_coords)[1]%4==3:
        current_coords = current_coords[:,2:]
    for coord in range(4):
        # looking at each coordinate individually
        for i in range(1,int((num_neighbours/2)+1)):
            # Generating a neighbour in both 'directions' by adding or subtracting the required number of 'steps' with a given step size
            neighbour_1 = np.copy(current_coords)[:,:-1]
            neighbour_2 = np.copy(current_coords)[:,:-1]
            neighbour_1[:,coord] += step_size
            neighbour_2[:,coord] -= step_size
            # Estimating the signals produced by these neighbours
            neighbour_1_signal = signal_estimator.signal_est_2(neighbour_1,cal_process_row)
            neighbour_2_signal = signal_estimator.signal_est_2(neighbour_2,cal_process_row)
            # Replacing the current coordinates with the neighbour if this signal is better than the current signal
            if neighbour_1_signal > current_coords[:,-1]:
                current_coords[:,-1] = neighbour_1_signal.item()
                current_coords[:,coord] = neighbour_1[:,coord]
            if neighbour_2_signal > current_coords[:,-1]:
                current_coords[:,-1] = neighbour_2_signal.item()
                current_coords[:,coord] = neighbour_2[:,coord]
    return current_coords


def hill_climb_alg(input_coords,cal_process,num_iters,step_size,num_neighbours):
    """Performs a hill-climb on a whole set of coordinates, appling the hill_climb() function with the desired parameters for each 
       input-output pair if their signal is below the threshold of -3.
       
       PARAMETERS:
                   input_coords is the array containing the four coordinates and signals for every input-output pair of ports.
                   cal_process is the array containing the calibration data to be used to perform the signal estimation in the hill-climb.
                   num_iters is the desired number of iterations for the algorithm to be repeated.
                   step_size is the desired step size to be used in the hill-climb.
                   num_neighbours is the desired number of neighbours to be generated in the hill-climb."""
    for iter in range(num_iters):
        counter=0
        # Checking if each input-output pair requires improvement (if the signal is below -3)
        for row in range(2304):
            if input_coords[row,-1]<-3:
                counter+=1
                # Carrying out a hill-climb step if improvement is required
                input_coords[row,2:] = hill_climb(np.reshape(input_coords[row,:],(1,-1)),np.reshape(cal_process[row,:],(1,-1)),step_size,num_neighbours)
    return input_coords, counter
        


